视图：
	作用：接受Web请求并响应Web对象。
	本质：视图就是python中的函数。
	
	响应：网页：1.重定向
		    2.错误视图：①404：匹配错误（可以自己定义）
			*******	       在templates下定义（去setting.py中配置）
					DEBUG = False
					ALLOWED_HOSTS = ['*']
				②500：服务器内部错误，在视图代码中出现错误
				③400：错误出现在客服的操作
	      JSON数据：
	      
	      过程：用户输入网址【网址】-> django获取网址信息（去除IP与端口）
		【虚拟路径与文件名】->url管理器：逐个匹配urlconf，记录视图函数
		【视图函数名】->视图管理器（找到对应的视图去执行）
		【响应的数据】->返回结果给游览器
	
	url配置：
		配置流程：
			①制定根级url配置文件：
				settings.py文件中的ROOT_URLCONF = 'test1.urls'
			②urlpatterns：一个实例的列表。
				url对象：三个参数（正则表达式、视图名称、名称）
			③url匹配正则的注意事项：
				如果想从url中读取一个值，需要对正则加小括号
				匹配正则前方不需要加‘/’
				正则钱需要加‘r’，表示字符串不转义
	
	引入其他url配置：在应用中创建urls.py文件，在工程urls.py使用include方法
			url(r'^',include('myApp.urls'))

	url的反向解析：如果在视图、模板中使用了硬编码，在url配置发生改变时，动态生成链接地址
		解决：在使用链接时，通过url配置的名称，动态生成url地址
		作用：使用url模板

	视图函数：
		定义视图：
			视图参数：1.一个HttpRequest的实例
				  2.通过正则表达式获取的参数
			位子：一般在views.py文件下定义

	HttpRequest对象:服务器接收http请求后，会根据报文创建一个HttpRequestd对                          象，给视图的第一个参数，调用视图时，传递给视图
                属性：①path:请求的完整路径，不包括域名、端口
		      ②method：表示请求的方式，常用有GET、POST
		      ③encoding：表示浏览器提交的数据编码方式
		      ④GET/POST:类似字典的对象，包含了get(post)请求的所有参数
		      ⑤FILES：类似字典的对象，包含了所有上传的文件
		      ⑥COOKIES:字典，包含所有的cookie
		      ⑦session：类似字典的对象，表示当前会话

		方法：is_ajax()：如果是通过XMLHttpRequestf发起的，返回True
		
		QureyDict对象：request对象中的GET,POST都属于QueryDict对象

		GET：获取游览器给服务器的数据
		POST：#'django.middleware.csrf.CsrfViewMiddleware',

	HttpResponse对象：给浏览器返回对象，HttpResponse对象有程序员创建
		用法：1.不调用模板：直接返回数据 return HttpResponse('post')
		      2.调用模板：使用render方法 
                        return render(request,'myApp/regist.html')

			render:
			 ①原型：render（request,templateName,context）
			 ②作用：结合数据和模板，返回完整的HTML页面
			 ③参数：request：请求体对象
				 templateName:模板路径
				 context:传递给需要渲染在模板上的数据
		
		属性：  ①content:表示返回内容
			②charset:编码格式
			③status.code:响应状态码
			④content-type:指定输出的MIME类型

		方法：  ①init：使用页面的内容实例化HttpResponse
			②write(content)：以文件的形式写入
			③flush():以文件的形式输出缓冲区
			④set_cookie(key,value='',max_age=None,exprise=None)
			⑤delete_cookie(key)：删除cookie，如果删除一个不存在的
					      key，就当做什么都没有发生
		
		子类:
			①：HttpResponseRedirect:
				1.功能：重定向，服务器端跳转
				2.简写：redirect（to） 
					return redirect('/redirect2')
			②：JsonResponse：返回JSON数据，一般用于异步请求
					Content.type类型为application/json

	状态保持：http协议是无状态的，每次请求都是一次新的请求，不记得以前的请求，客户端与服务器的一次通信就是一次会话。实现状态的保持，在客服端或者服务端存储有关会话的数据。
		存储的方式：cookie  ：所有的数据都存储在客户端
			    session ：所有的数据都存储在服务端，
				      在客户端用cookie存储session_id

		状态保持的目的：在一段时间内跟踪请求者的状态，可以实现跨页面访				问当前请求者的数据（不同请求者不共享数据，1:1）

		启用session：seeting->INSTALLED_APPS->'django.contrib.sessions'
             MIDDLEWARE>'django.contrib.sessions.middleware.SessionMiddleware'

		使用session:启用后，每个HttpResquest对象都有一个session数据，就是一个类似字典的对象
			方法：①get(key,default=None):根据键获取session值
			      ②clear():清空所有的对话
			      ③flush():删除当前的会话，并删除会话的cookie
			      ④设置过期时间：set.expirey(value)
					如果不设置，两个星期后过期
				整数：request.session.set_expiry(10)  10s后过期
				时间对象：
				0:关闭浏览器后失效
				None:永不过期

		 ****Html中action末尾一定要加‘/’
	
		  存储session的位置：.........???
		  
		  使用redis缓存session：pip install django-redis-sessions
			在setting.py末尾添加
			SESSION_ENGINE = 'redis_sessions.session'
			SESSION_REDIS_HOST = 'localhost'
			SESSION_REDIS_PORT = 6379
			SESSION_REDIS_DB = 0
			SESSION_REDIS_PASSWORD = '520520'
			SESSION_REDIS_PREFIX = 'session'
		